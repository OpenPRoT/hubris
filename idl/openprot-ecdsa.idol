// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2024 Advanced Micro Devices, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Cryptographic operations interface for ECDSA-384 signing and verification
//
// Data Formats:
// 
// ECDSA-384 Signatures:
//   - Format: Raw signature format (r || s)
//   - Structure: r-value || s-value
//   - Size: Fixed 96 bytes (48 + 48)
//   - r: 48 bytes, big-endian integer (signature r component)
//   - s: 48 bytes, big-endian integer (signature s component)
//   - Both r and s are in range [1, n-1] where n is the P-384 curve order
//   - Leading zeros are preserved to maintain fixed 48-byte field size
//   - Compliant with NIST FIPS 186-4 and SEC1 standards
//
// P-384 Public Keys:
//   - Format: Raw affine coordinates (x || y)
//   - Structure: x-coordinate || y-coordinate
//   - Size: Fixed 96 bytes (48 + 48)
//   - x: 48 bytes, big-endian integer (point x-coordinate)
//   - y: 48 bytes, big-endian integer (point y-coordinate)
//   - No SEC1 prefix byte (0x04) - raw coordinates only
//   - Coordinates represent a point on the NIST P-384 elliptic curve
//   - All coordinates use big-endian (network byte order) encoding
//
// SHA-384 Hashes:
//   - Size: Fixed 48 bytes
//   - Format: Raw binary hash digest output
//   - Pre-computed by caller (this interface does not perform hashing)
//   - Must be computed over the actual message to be signed/verified
//
// Key IDs:
//   - Type: 32-bit unsigned integer
//   - Implementation-defined mapping to private key material
//   - Used only for signing operations (verify uses explicit public key)
//   - Key storage and lifecycle management is implementation-specific
//
// Byte Order:
//   - All multi-byte integers use big-endian encoding (network byte order)
//   - This matches NIST, SEC1, and RustCrypto conventions
//   - No byte swapping required when interfacing with standard crypto libraries
//
// Design Rationale:
//   - Fixed sizes enable static allocation and predictable memory usage
//   - Big-endian encoding ensures compatibility with cryptographic standards
//   - Zero-copy operations possible with proper alignment
//   - Direct compatibility with hardware crypto accelerators
Interface(
    name: "OpenPRoTEcdsa",
    ops: {
        "ecdsa384_sign": (
            doc: "Sign a hash using ECDSA-384 with the specified private key.
                  
                  Format: Raw signature (r || s), 96 bytes total
                  - r: 48 bytes, big-endian integer
                  - s: 48 bytes, big-endian integer
                  
                  All multi-byte values use big-endian (network byte order) encoding.",
            args: {
                "key_id": "u32",
            },
            leases: {
                "hash": (type: "[u8]", read: true, max_len: Some(48)), 
                    // SHA-384 hash, 48 bytes
                "signature": (type: "[u8]", write: true, max_len: Some(96)), 
                    // Raw r || s (48 + 48 bytes, big-endian)
            },
            reply: Result(
                ok: "()",
                err: CLike("EcdsaError"),
            ),
        ),
        
        "ecdsa384_verify": (
            doc: "Verify an ECDSA-384 signature against a hash using the provided public key.
                  
                  Signature format: Raw (r || s), 96 bytes total
                  - r: 48 bytes, big-endian integer
                  - s: 48 bytes, big-endian integer
                  
                  Public key format: Raw affine coordinates (x || y), 96 bytes total
                  - x: 48 bytes, big-endian integer
                  - y: 48 bytes, big-endian integer
                  
                  All multi-byte values use big-endian (network byte order) encoding.",
            args: {},
            leases: {
                "hash": (type: "[u8]", read: true, max_len: Some(48)),
                    // SHA-384 hash, 48 bytes
                "signature": (type: "[u8]", read: true, max_len: Some(96)),
                    // Raw r || s (48 + 48 bytes, big-endian)
                "public_key": (type: "[u8]", read: true, max_len: Some(96)),
                    // Raw x || y (48 + 48 bytes, big-endian)
            },
            reply: Result(
                ok: "bool",
                err: CLike("EcdsaError"),
            ),
            idempotent: true,
        ),
    }
)
